#!/bin/bash

# =================================================================
# GTOne RAG Í≥µÌÜµ Ìï®Ïàò ÎùºÏù¥Î∏åÎü¨Î¶¨
# ÏúÑÏπò: scripts/common.sh
# =================================================================

# ÏÉâÏÉÅ Ï†ïÏùò
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m'

# ÌîÑÎ°úÏ†ùÌä∏ ÏÑ§Ï†ï
PROJECT_NAME="GTOne RAG"
DEFAULT_PORTS=(6333 6379 18000 8501)
PORT_NAMES=("Qdrant" "Redis" "FastAPI" "Streamlit")

# =================================================================
# Î°úÍπÖ Ìï®ÏàòÎì§
# =================================================================

log_info() {
    echo -e "${BLUE}‚ÑπÔ∏è $1${NC}"
}

log_success() {
    echo -e "${GREEN}‚úÖ $1${NC}"
}

log_warning() {
    echo -e "${YELLOW}‚ö†Ô∏è $1${NC}"
}

log_error() {
    echo -e "${RED}‚ùå $1${NC}"
}

log_step() {
    echo -e "\n${PURPLE}üîÑ $1${NC}"
    echo "$(printf '%.0s=' {1..50})"
}

# =================================================================
# ÌôòÍ≤Ω ÌôïÏù∏ Ìï®ÏàòÎì§
# =================================================================

check_command() {
    local cmd=$1
    local install_hint=$2

    if ! command -v "$cmd" &> /dev/null; then
        log_error "$cmdÍ∞Ä ÏÑ§ÏπòÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§."
        if [[ -n "$install_hint" ]]; then
            echo "   ÏÑ§Ïπò Î∞©Î≤ï: $install_hint"
        fi
        return 1
    fi
    return 0
}

check_docker() {
    check_command "docker" "https://docs.docker.com/get-docker/" || return 1

    if ! docker info > /dev/null 2>&1; then
        log_error "Docker Îç∞Î™¨Ïù¥ Ïã§ÌñâÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§."
        echo "   Docker DesktopÏùÑ ÏãúÏûëÌïòÍ±∞ÎÇò 'sudo systemctl start docker' Ïã§Ìñâ"
        return 1
    fi

    log_success "Docker ÌôòÍ≤Ω ÌôïÏù∏Îê®"
    return 0
}

check_conda() {
    check_command "conda" "https://docs.conda.io/en/latest/miniconda.html" || return 1
    log_success "Conda ÌôòÍ≤Ω ÌôïÏù∏Îê®: $(conda --version)"
    return 0
}

# =================================================================
# Ìè¨Ìä∏ Í¥ÄÎ¶¨ Ìï®ÏàòÎì§
# =================================================================

check_port() {
    local port=$1

    if lsof -i:$port > /dev/null 2>&1; then
        return 1  # Ìè¨Ìä∏ ÏÇ¨Ïö© Ï§ë
    else
        return 0  # Ìè¨Ìä∏ ÏÇ¨Ïö© Í∞ÄÎä•
    fi
}

get_port_process() {
    local port=$1
    lsof -i:$port 2>/dev/null | tail -n +2 | head -1
}

kill_port_process() {
    local port=$1
    local force=${2:-false}

    if check_port $port; then
        return 0  # Ìè¨Ìä∏Í∞Ä Ïù¥ÎØ∏ ÏÇ¨Ïö© Í∞ÄÎä•
    fi

    local process_info=$(get_port_process $port)
    if [[ -n "$process_info" ]]; then
        log_warning "Ìè¨Ìä∏ $portÍ∞Ä ÏÇ¨Ïö© Ï§ëÏûÖÎãàÎã§:"
        echo "   $process_info"

        if $force; then
            log_info "Ìè¨Ìä∏ $port ÌîÑÎ°úÏÑ∏Ïä§Î•º Í∞ïÏ†ú Ï¢ÖÎ£åÌï©ÎãàÎã§..."
            lsof -ti:$port | xargs kill -9 2>/dev/null
            sleep 2
        else
            echo "   Í∏∞Ï°¥ ÌîÑÎ°úÏÑ∏Ïä§Î•º Ï¢ÖÎ£åÌïòÏãúÍ≤†ÏäµÎãàÍπå? (y/n)"
            read -r response
            if [[ "$response" =~ ^[Yy]$ ]]; then
                lsof -ti:$port | xargs kill -9 2>/dev/null
                sleep 2
            else
                return 1
            fi
        fi
    fi

    return 0
}

# =================================================================
# ÏÑúÎπÑÏä§ ÎåÄÍ∏∞ Ìï®ÏàòÎì§
# =================================================================

wait_for_service() {
    local url=$1
    local timeout=${2:-30}
    local service_name=${3:-"Service"}
    local check_interval=${4:-2}

    log_info "$service_name Ï§ÄÎπÑ ÎåÄÍ∏∞ Ï§ë..."

    for i in $(seq 1 $timeout); do
        # HTTP ÏÑúÎπÑÏä§ Ï≤¥ÌÅ¨
        if [[ "$url" =~ ^https?:// ]]; then
            if curl -s --connect-timeout 2 "$url" > /dev/null 2>&1; then
                log_success "$service_name Ï§ÄÎπÑ ÏôÑÎ£å (${i}Ï¥à)"
                return 0
            fi
        # Redis Ï≤¥ÌÅ¨
        elif [[ "$url" =~ ^redis:// ]]; then
            if redis-cli -h localhost -p 6379 ping > /dev/null 2>&1; then
                log_success "$service_name Ï§ÄÎπÑ ÏôÑÎ£å (${i}Ï¥à)"
                return 0
            fi
        fi

        # ÏßÑÌñâ ÏÉÅÌô© ÌëúÏãú
        if [[ $((i % 10)) -eq 0 ]]; then
            log_info "ÎåÄÍ∏∞ Ï§ë... ${i}Ï¥à Í≤ΩÍ≥º"
        else
            echo -n "."
        fi

        sleep $check_interval
    done

    echo ""  # Ï§ÑÎ∞îÍøà
    log_warning "$service_name Ï§ÄÎπÑ ÏãúÍ∞Ñ Ï¥àÍ≥º (${timeout}Ï¥à)"
    return 1
}

wait_for_docker_container() {
    local container_name=$1
    local timeout=${2:-60}

    log_info "Docker Ïª®ÌÖåÏù¥ÎÑà '$container_name' Ï§ÄÎπÑ ÎåÄÍ∏∞..."

    for i in $(seq 1 $timeout); do
        if docker ps --format "{{.Names}}" | grep -q "^$container_name$"; then
            # Ïª®ÌÖåÏù¥ÎÑàÍ∞Ä Ïã§Ìñâ Ï§ëÏù∏ÏßÄ ÌôïÏù∏
            local status=$(docker inspect $container_name --format='{{.State.Status}}')
            if [[ "$status" == "running" ]]; then
                log_success "Ïª®ÌÖåÏù¥ÎÑà '$container_name' Ï§ÄÎπÑ ÏôÑÎ£å (${i}Ï¥à)"
                return 0
            fi
        fi

        if [[ $((i % 15)) -eq 0 ]]; then
            log_info "ÎåÄÍ∏∞ Ï§ë... ${i}Ï¥à Í≤ΩÍ≥º"
        else
            echo -n "."
        fi

        sleep 1
    done

    echo ""
    log_warning "Ïª®ÌÖåÏù¥ÎÑà '$container_name' Ï§ÄÎπÑ ÏãúÍ∞Ñ Ï¥àÍ≥º"
    return 1
}

# =================================================================
# ÌôòÍ≤ΩÎ≥ÄÏàò Í¥ÄÎ¶¨ Ìï®ÏàòÎì§
# =================================================================

load_environment() {
    local script_dir=$(cd "$(dirname "${BASH_SOURCE[1]}")" && pwd)
    local env_files=(
        "$script_dir/.env"
        "$script_dir/../.env"
        "$script_dir/../../.env"
        "./.env"
    )

    for env_file in "${env_files[@]}"; do
        if [[ -f "$env_file" ]]; then
            set -a
            source "$env_file"
            set +a
            log_success "ÌôòÍ≤Ω ÏÑ§Ï†ï Î°úÎìú: $env_file"
            return 0
        fi
    done

    log_warning "ÌôòÍ≤Ω ÏÑ§Ï†ï ÌååÏùºÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§. Í∏∞Î≥∏Í∞í ÏÇ¨Ïö©"
    return 1
}

set_default_env() {
    # Í∏∞Î≥∏ ÌôòÍ≤ΩÎ≥ÄÏàò ÏÑ§Ï†ï
    export QDRANT_PORT=${QDRANT_PORT:-6333}
    export REDIS_PORT=${REDIS_PORT:-6379}
    export API_PORT=${API_PORT:-18000}
    export STREAMLIT_PORT=${STREAMLIT_PORT:-8501}
    export OLLAMA_HOST=${OLLAMA_HOST:-"http://172.16.15.112:11434"}
    export API_BASE_URL=${API_BASE_URL:-"http://localhost:$API_PORT"}
    export LOG_LEVEL=${LOG_LEVEL:-"INFO"}
    export DOCKER_NETWORK=${DOCKER_NETWORK:-"gtrag-network"}
}

# =================================================================
# ÌååÏùº/ÎîîÎ†âÌÜ†Î¶¨ Í¥ÄÎ¶¨ Ìï®ÏàòÎì§
# =================================================================

ensure_directory() {
    local dir=$1
    if [[ ! -d "$dir" ]]; then
        mkdir -p "$dir"
        log_info "ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±: $dir"
    fi
}

find_project_root() {
    local current_dir=$(pwd)
    local search_dir="$current_dir"

    # ÏµúÎåÄ 5 Î†àÎ≤®ÍπåÏßÄ ÏÉÅÏúÑ ÎîîÎ†âÌÜ†Î¶¨ Í≤ÄÏÉâ
    for i in {1..5}; do
        if [[ -d "$search_dir/infrastructure" && -d "$search_dir/backend" && -d "$search_dir/frontend" ]]; then
            echo "$search_dir"
            return 0
        fi
        search_dir=$(dirname "$search_dir")
        if [[ "$search_dir" == "/" ]]; then
            break
        fi
    done

    log_error "ÌîÑÎ°úÏ†ùÌä∏ Î£®Ìä∏ ÎîîÎ†âÌÜ†Î¶¨Î•º Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§."
    echo "ÌòÑÏû¨ ÏúÑÏπò: $current_dir"
    echo "ÌïÑÏöîÌïú ÎîîÎ†âÌÜ†Î¶¨: infrastructure/, backend/, frontend/"
    return 1
}

# =================================================================
# Ìó¨Ïä§Ï≤¥ÌÅ¨ Ìï®ÏàòÎì§
# =================================================================

detailed_health_check() {
    local service_name=$1
    local url=$2

    case $service_name in
        "Qdrant")
            if curl -s "$url" | grep -q "\"status\":\"ok\""; then
                return 0
            fi
            ;;
        "Redis")
            if redis-cli -h localhost -p ${REDIS_PORT:-6379} ping 2>/dev/null | grep -q "PONG"; then
                return 0
            fi
            ;;
        "API")
            if curl -s "$url" | grep -q "\"status\":\"healthy\""; then
                return 0
            fi
            ;;
        "UI")
            if curl -s --connect-timeout 3 "$url" > /dev/null 2>&1; then
                return 0
            fi
            ;;
    esac

    return 1
}

comprehensive_health_check() {
    log_step "Ï†ÑÏ≤¥ ÏãúÏä§ÌÖú Ìó¨Ïä§Ï≤¥ÌÅ¨ ÏàòÌñâ"

    local all_healthy=true
    local services=(
        "Qdrant:http://localhost:${QDRANT_PORT:-6333}/health"
        "Redis:redis://localhost:${REDIS_PORT:-6379}"
        "API:http://localhost:${API_PORT:-18000}/v1/health"
        "UI:http://localhost:${STREAMLIT_PORT:-8501}/_stcore/health"
    )

    for service_info in "${services[@]}"; do
        IFS=':' read -r name url <<< "$service_info"

        echo -n "   $name: "
        if detailed_health_check "$name" "$url"; then
            log_success "Ï†ïÏÉÅ"
        else
            log_error "ÎπÑÏ†ïÏÉÅ"
            all_healthy=false
        fi
    done

    if $all_healthy; then
        log_success "Î™®Îì† ÏÑúÎπÑÏä§Í∞Ä Ï†ïÏÉÅÏûÖÎãàÎã§"
        return 0
    else
        log_warning "ÏùºÎ∂Ä ÏÑúÎπÑÏä§Ïóê Î¨∏Ï†úÍ∞Ä ÏûàÏäµÎãàÎã§"
        return 1
    fi
}

# =================================================================
# ÏóêÎü¨ Ï≤òÎ¶¨ Ìï®ÏàòÎì§
# =================================================================

handle_error() {
    local exit_code=$1
    local service_name=$2
    local log_file=${3:-""}

    if [[ $exit_code -ne 0 ]]; then
        log_error "$service_name ÏãúÏûë Ïã§Ìå® (exit code: $exit_code)"

        if [[ -f "$log_file" ]]; then
            log_info "ÎßàÏßÄÎßâ 10Ï§ÑÏùò Î°úÍ∑∏:"
            tail -10 "$log_file" | sed 's/^/    /'
            echo ""
        fi

        log_info "Î¨∏Ï†ú Ìï¥Í≤∞ Î∞©Î≤ï:"
        echo "  1. Î°úÍ∑∏ Ï†ÑÏ≤¥ ÌôïÏù∏: cat $log_file"
        echo "  2. Ìè¨Ìä∏ Ï∂©Îèå ÌôïÏù∏: lsof -i:${API_PORT:-18000}"
        echo "  3. Í∞úÎ≥Ñ ÏÑúÎπÑÏä§ Ïû¨ÏãúÏûë"
        echo "  4. ÏãúÏä§ÌÖú Ï†ïÎ¶¨ ÌõÑ Ïû¨ÏãúÏûë: ./scripts/stop_all.sh && ./scripts/start_all.sh"

        return 1
    fi

    return 0
}

cleanup_on_exit() {
    local service_name=$1
    local pid_file=${2:-""}

    echo ""
    log_warning "Ï§ëÎã® Ïã†Ìò∏Î•º Î∞õÏïòÏäµÎãàÎã§. $service_name Ï†ïÎ¶¨ Ï§ë..."

    if [[ -f "$pid_file" ]]; then
        local pid=$(cat "$pid_file")
        if kill -0 "$pid" 2>/dev/null; then
            kill "$pid" 2>/dev/null
            log_info "ÌîÑÎ°úÏÑ∏Ïä§ $pid Ï¢ÖÎ£åÎê®"
        fi
        rm -f "$pid_file"
    fi

    exit 130
}

# =================================================================
# ÏÇ¨Ïö©Î≤ï ÏòàÏãú
# =================================================================

show_usage_example() {
    cat << 'EOF'
# Í≥µÌÜµ Ìï®Ïàò ÏÇ¨Ïö© ÏòàÏãú:

# 1. Í≥µÌÜµ Ìï®Ïàò Î°úÎìú
source "scripts/common.sh"

# 2. ÌôòÍ≤Ω ÏÑ§Ï†ï
load_environment
set_default_env

# 3. Í∏∞Î≥∏ ÌôïÏù∏
check_docker || exit 1
find_project_root || exit 1

# 4. Ìè¨Ìä∏ ÌôïÏù∏ Î∞è Ï†ïÎ¶¨
kill_port_process 8501 false

# 5. ÏÑúÎπÑÏä§ ÎåÄÍ∏∞
wait_for_service "http://localhost:6333/health" 30 "Qdrant"

# 6. Ìó¨Ïä§Ï≤¥ÌÅ¨
comprehensive_health_check
EOF
}

# =================================================================
# Ï¥àÍ∏∞Ìôî Ìï®Ïàò
# =================================================================

init_common() {
    # Í∏∞Î≥∏ ÌôòÍ≤Ω ÏÑ§Ï†ï
    set_default_env

    # Í∏∞Î≥∏ ÎîîÎ†âÌÜ†Î¶¨ ÏÉùÏÑ±
    ensure_directory "logs"

    # ÏãúÍ∑∏ÎÑê Ìï∏Îì§Îü¨ ÏÑ§Ï†ï
    trap 'cleanup_on_exit "Common Script"' INT TERM
}

# Ïä§ÌÅ¨Î¶ΩÌä∏Í∞Ä ÏßÅÏ†ë Ïã§ÌñâÎêú Í≤ΩÏö∞ ÏÇ¨Ïö©Î≤ï ÌëúÏãú
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    echo "GTOne RAG Í≥µÌÜµ Ìï®Ïàò ÎùºÏù¥Î∏åÎü¨Î¶¨"
    echo "Ïù¥ ÌååÏùºÏùÄ Îã§Î•∏ Ïä§ÌÅ¨Î¶ΩÌä∏ÏóêÏÑú sourceÎ°ú Î°úÎìúÌïòÏó¨ ÏÇ¨Ïö©Ìï©ÎãàÎã§."
    echo ""
    show_usage_example
fi